to do
/////

* Create sandbox directory for a distutils packaging of what is in Python 2.7.

* Use rpartition for getting the package of a module.

    + Make sure that an empty string is acceptable for __package__.

* Create meta_path importer for sys.path.

    + Document.

* Refactor __import__.

    + Create a greatest common denominator function for __import__/import_module
      that takes in an absolute module name and performs the import.
    + Use GCD import for __import__.
    + Use GCD import for import_module.

* Implement PEP 302 protocol for loaders (should just be a matter of testing).

    + Built-in.
    + Frozen.
    + Extension.
    + Source/bytecode.

* Public API left to expose (w/ docs!)

  + abc

      - Finder

        * find_module

      - Loader

        * load_module

      - (?) Importer(Finder, Loader)

      - ResourceLoader(Loader)

        * get_data

      - InspectLoader(Loader)

        * is_package
        * get_code
        * get_source

      - (?) SourceLoader(ResourceLoader)

        * source_path
        * bytecode_path
        * write_bytecode

  + util

      - get_module decorator (new name)
      - check_name decorator (new name)
      - resolve_name

  + machinery

      - (?) Chained path hook/finder
      - (?) FileFinder
      - Extensions importers

          * ExtensionFinder
          * (?) Loader

      - Source/bytecode importers

          * SourceFinder
          * (?) Loader

* Write benchmark suite.

* OPTIMIZE!

  + Fast path absolute name.
  + Fast path pulling from sys.modules.

* Bootstrap importlib as implementation of builtins.__import__

* Replace standard library modules.

  + imp
  + py_compile
  + compileall
