to do
/////

* Change failed loading based on PEP 302 changes.

* Refactor source/bytecode finder/loader code such that bytecode support is a
  subclass of source support (makes it nicer for VMs that don't use CPython
  bytecode).

* Implement PEP 302 protocol for loaders (should just be a matter of testing).

    + Built-in.
    + Frozen.
    + Extension.
    + Source/bytecode.

* Public API left to expose (w/ docs!)

  + abc

      - Finder

        * find_module

      - Loader

        * load_module

      - (?) Importer(Finder, Loader)

      - ResourceLoader(Loader)

        * get_data

      - InspectLoader(Loader)

        * is_package
        * get_code
        * get_source

      - (?) SourceLoader(ResourceLoader)

        * source_path
        * bytecode_path
        * write_bytecode (not abstract)

  + util

      - get_module decorator (rename: module_for_loader)
      - set___package__ decorator

  + machinery

      - (?) Chained path hook/finder
      - Extensions importers

          * ExtensionFinder
          * (?) Loader

      - Source/bytecode importers

          * SourceFinder
          * (?) Loader

      - PathFinder

* Make sure that there is documentation *somewhere* fully explaining the
semantics of import that can be referenced from the package's documentation
(even if it is in the package documentation itself, although it might be best
in the language specification).

* Write benchmark suite.

* OPTIMIZE!

  + Fast path absolute name.
  + Fast path pulling from sys.modules.

* Bootstrap importlib as implementation of builtins.__import__

* Replace standard library modules.

  + imp
  + py_compile
  + compileall
