to do
/////

* Use rpartition for getting the package of a module.

    + Make sure there is a test for the empty string as acceptable for
      __package__.

* Implement PEP 302 protocol for loaders (should just be a matter of testing).

    + Built-in.
    + Frozen.
    + Extension.
    + Source/bytecode.

* Public API left to expose (w/ docs!)

  + abc

      - Finder

        * find_module

      - Loader

        * load_module

      - (?) Importer(Finder, Loader)

      - ResourceLoader(Loader)

        * get_data

      - InspectLoader(Loader)

        * is_package
        * get_code
        * get_source

      - (?) SourceLoader(ResourceLoader)

        * source_path
        * bytecode_path
        * write_bytecode (not abstract)

  + util

      - get_module decorator (rename: module_for_loader)

  + machinery

      - (?) Chained path hook/finder
      - (?) FileFinder
      - Extensions importers

          * ExtensionFinder
          * (?) Loader

      - Source/bytecode importers

          * SourceFinder
          * (?) Loader

      - PathFinder

* Write benchmark suite.

* OPTIMIZE!

  + Fast path absolute name.
  + Fast path pulling from sys.modules.

* Bootstrap importlib as implementation of builtins.__import__

* Replace standard library modules.

  + imp
  + py_compile
  + compileall
